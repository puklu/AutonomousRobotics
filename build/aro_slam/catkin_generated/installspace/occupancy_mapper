#!/usr/bin/env python3
"""Occupancy mapping node.

The node operates in 2D, Z coordinate of input points in the map frame is
discarded.
"""
from __future__ import absolute_import, division, print_function
from aro_slam import (
    OccupancyMap,
    position,
    timer,
    timing,
    transform,
    viewpoint,
)
from nav_msgs.msg import OccupancyGrid
import rospy
from ros_numpy import numpify
from sensor_msgs.msg import PointCloud2
from tf2_py import TransformException
import tf2_ros


class OccupancyMapper(object):
    def __init__(self):
        # Sensor frame is needed to recover sensor origin for updating
        # occupancy grid (the cloud need not be in the sensor frame).
        self.sensor_frame = rospy.get_param('~sensor_frame', None)

        # Fixed map frame, parent of the odometry frame above.
        self.map_frame = rospy.get_param('~map_frame', 'map')

        # Throw messages older than a threshold [s].
        self.max_age = rospy.get_param('~max_age', 0.25)

        # Timeout waiting for TF transforms [s].
        self.timeout = rospy.get_param('~timeout', 0.25)

        # Wait between map updates to reduce computation [s].
        # Increasing this interval increases the time needed to update
        # occupancy grid, e.g. to change a free cell to occupied when obstacle
        # appears and vice versa.
        self.map_update_interval = rospy.get_param('~map_update_interval', 0.2)

        # Occupancy grid resolution .
        self.grid_res = rospy.get_param('~grid_res', 0.05)

        # Additive update for seeing trough the cell.
        self.empty_update = rospy.get_param('~empty_update', -1.0)

        # Additive update for hitting the cell.
        self.occupied_update = rospy.get_param('~occupied_update', 1.0)

        # Minimum accumulated occupancy value, lower values are clipped at
        # this value. Avoids overconfident belief in any cell being free.
        self.min_occupancy = rospy.get_param('~min_occupancy', -10.0)

        # Maximum accumulated occupancy value, higher values are clipped at
        # this value. Avoids overconfident belief in any cell being occupied.
        self.max_occupancy = rospy.get_param('~max_occupancy', 10.0)

        # A threshold above which the cell is considered occupied.
        self.occupied_threshold = rospy.get_param('~occupied_threshold', 5.0)

        # The time of previous map update.
        self.last_update_stamp = None

        # Occupancy grid for planning, and noise suppression.
        self.occupancy = OccupancyMap(self.map_frame,
                                      resolution=self.grid_res,
                                      empty_update=self.empty_update,
                                      occupied_update=self.occupied_update,
                                      min=self.min_occupancy,
                                      max=self.max_occupancy,
                                      occupied=self.occupied_threshold)

        self.tf = tf2_ros.Buffer()
        self.tf_sub = tf2_ros.TransformListener(self.tf)

        self.occ_pub = rospy.Publisher('occupancy', OccupancyGrid, queue_size=5, latch=True)

        self.points_sub = rospy.Subscriber('cloud', PointCloud2, self.process_cloud, queue_size=5)

    @timing
    def process_cloud(self, msg):
        t0 = timer()
        assert isinstance(msg, PointCloud2)

        if msg.width * msg.height == 0:
            rospy.logwarn_throttle(5.0, 'Skipping an empty point cloud.')
            return

        age = (rospy.Time.now() - msg.header.stamp).to_sec()
        if age > self.max_age:
            rospy.logwarn_throttle(5.0, 'Skipping message %.2f s old (older than %.2f s).'
                                   % (age, self.max_age))
            return

        try:
            to_map = self.tf.lookup_transform(self.map_frame, msg.header.frame_id, msg.header.stamp,
                                              rospy.Duration(self.timeout))
            to_map = numpify(to_map.transform)
        except TransformException as ex:
            rospy.logwarn_throttle(5.0, 'Could not transform cloud in %s to map frame %s: %s.',
                                   msg.header.frame_id, self.map_frame, ex)
            return

        x_struct = numpify(msg)
        x_struct = transform(to_map, x_struct)

        # Update the occupancy grid from viewpoints to measured positions.
        x = position(x_struct)
        origin = viewpoint(x_struct)
        self.occupancy.update(origin.T, x.T, msg.header.stamp)
        if self.occ_pub.get_num_connections() > 0:
            self.occ_pub.publish(self.occupancy.to_msg())

        rospy.loginfo('Occupancy map updated with %i measurements (%.3g s).',
                      x_struct.size, timer() - t0)


def main():
    rospy.init_node('occupancy_mapper', log_level=rospy.INFO)
    node = OccupancyMapper()
    rospy.spin()


if __name__ == '__main__':
    main()
